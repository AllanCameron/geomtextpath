% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grob_textpath.R
\name{textpathGrob}
\alias{textpathGrob}
\title{Draw text on a path.}
\usage{
textpathGrob(
  label,
  x = 0.5,
  y = 0.5,
  id = 1L,
  just = "centre",
  hjust = NULL,
  vjust = NULL,
  halign = "left",
  angle = 0,
  keep_straight = FALSE,
  gp_text = gpar(),
  gp_path = gpar(),
  cut_path = NA,
  flip_inverted = TRUE,
  polar_params = NULL,
  padding = unit(0.15, "inch"),
  default.units = "npc",
  name = NULL,
  vp = NULL
)
}
\arguments{
\item{label}{A \code{character} vector.}

\item{x}{A \code{numeric} vector.}

\item{y}{A \code{numeric} vector.}

\item{id}{A \code{numeric} vector used to separate locations in \code{x} and \code{y} into
multiple lines. All locations with the same \code{id} belong to the same line.}

\item{just}{The justification of the text
    relative to its (x, y) location.  If there are two values, the first
    value specifies horizontal justification and the second value specifies
    vertical justification.  Possible string values are: \code{"left"},
    \code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
    and \code{"top"}.  For numeric values, 0 means left (bottom) alignment
    and 1 means right (top) alignment.
  }

\item{hjust}{A numeric vector specifying horizontal justification.
    If specified, overrides the \code{just} setting.}

\item{vjust}{A \code{numeric} vector specifying justification orthogonal to the
direction of the text. Alternatively a \code{\link[grid:unit]{unit()}} object to
directly set the offset from the path.}

\item{halign}{A \code{character(1)} describing how multi-line labels should
be justified. Can either be \code{"left"} (default), \code{"center"} or \code{"right"}.}

\item{angle}{a \code{numeric} vector either length 1 or the same length as \code{id}
describing the angle in degrees at which text should be rotated.}

\item{keep_straight}{a \code{logical(1)}, which if \code{TRUE}, keeps the letters of
a label on the same, straight baseline and if \code{FALSE} (default),
lets individual letters follow the curve. This might be helpful for noisy
paths.}

\item{gp_text, gp_path}{An object of class \code{"gpar"}, typically the output from
a call from the \code{\link[grid:gpar]{gpar()}} function. These are basically lists
of graphical parameters for the text and path respectively.}

\item{cut_path}{A \code{logical(1)} which if \code{TRUE} breaks the path
into two sections, one on either side of the string. If \code{FALSE}, the
path is plotted as a whole. The default, \code{NA}, will break the line if the
string has a \code{vjust} of between 0 and 1.}

\item{flip_inverted}{A \code{logical(1)} which if \code{TRUE} (default), inverts any
string where the majority of letters would be upside down along the path
are inverted to improve legibility. If \code{FALSE} letters are left as-is.}

\item{polar_params}{a list consisting of an x, y, and r component that
specifies the central point and radius of a circle around which
single-point labels will be wrapped.}

\item{padding}{A \code{\link[grid:unit]{unit()}} of length 1 to determine the
padding between path and text when the \code{cut_path} parameter trims the
path.}

\item{default.units}{A string indicating the default units to use
    if \code{x} or \code{y}
    are only given as numeric vectors.}

\item{name}{ A character identifier. }

\item{vp}{A Grid viewport object (or NULL).}
}
\value{
An object of class \code{gTree}, containing grobs.
}
\description{
This function creates (curved) text on a path.
}
\examples{
require(grid)

t <- seq(0, 2 * pi, length.out = 100)
grob <- textpathGrob(
  label = c(
    "Why I am making trigonometry jokes? Cos I can!",
    "I was never any good at sine language."
  ),
  x = c(t, t) / (2 * pi),
  y = c(cos(t), sin(t)) * 0.25 + 0.5,
  id = rep(1:2, each = length(t)),
  vjust = rep(0.5, 2 * length(t)),
  gp_text = gpar(lineheight = c(1.2, 1.2), fontsize = c(10, 10)),
  gp_path = gpar(lty = c(1, 2))
)

grid.newpage(); grid.draw(grob)
}
